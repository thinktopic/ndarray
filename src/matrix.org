(ns thi.ng.ndarray.matrix
  (:require
    [thi.ng.ndarray.core :as nd]
    [clojure.core.matrix :as mat]
    [clojure.core.matrix.protocols :as mp]
    [clojure.core.matrix.implementations :as imp]))

(defn zeros
  [shape]
  (let [size (apply * shape)
        ary (double-array size)]
    ;(.fill ary 0)

    (nd/ndarray :float64 ary shape)))

(extend-type thi.ng.ndarray.core.NDArray2float64
  mp/PImplementation
  (implementation-key [m]
    :ndarray)
  (meta-info [m]
    {:doc "thi.ng.ndarray matrix"})
  (construct-matrix   [m data]
    (nd/ndarray :float64 data (mat/shape data)))
  (new-vector         [m length]
    (nd/ndarray :float64 (double-array length) [length]))
  (new-matrix         [m rows columns]
    (nd/ndarray :float64 (double-array (* rows columns)) [rows columns]))
  (new-matrix-nd      [m shape]
    (nd/ndarray :float64 (double-array (apply * shape)) shape))
  (supports-dimensionality? [m dimensions]
    (<= dimensions 4))

  mp/PDimensionInfo
  (dimensionality [m]
    (count (nd/shape m)))
  (get-shape  [m]
    (nd/shape m))
  (is-scalar? [m] false)
  (is-vector? [m] false )
  (dimension-count [m dimension-number]
    (nth (nd/shape m) dimension-number))

  mp/PIndexedAccess
  (get-1d [m i] (nd/get-at m i))
  (get-2d [m row column] (nd/get-at m row column))
  (get-nd [m indexes]
    (apply nd/get-at m indexes))

  mp/PIndexedSetting
  (set-1d [m i x]
    (nd/set-at (mat/clone m) i x))

  (set-2d [m row column x]
    (nd/set-at (mat/clone m) row column x))

  (set-nd [m indexes x]
    (apply nd/set-at (mat/clone m) (concat indexes x)))

  (is-mutable? [m] true)

  mp/PIndexedSettingMutable
    (set-1d! [m x v]
      (nd/set-at m x v))

    (set-2d! [m x y v]
      (nd/set-at m x y v))

    (set-nd! [m indexes v]
      (apply nd/set-at m (concat indexes v)))

  mp/PMatrixCloning
  (clone [m]
    (let [dt (nd/data-type m)
          shape (nd/shape m)
          cloned-ary (.slice (nd/data m) 0)]
      (nd/ndarray dt cloned-ary shape)))

  ;; ---------------------------------------------------------------------------
  ;;  Optional protocols
  mp/PTypeInfo
  (element-type [m]
    (nd/data-type m))

  ;mp/PMatrixEquality
  ;(matrix-equals [a b]
  ;  (and
  ;    (m/same-shape? a b)
  ;    (.equiv a (to-matrix b))))

  ;mp/PMatrixMultiply
  ;(matrix-multiply [m a]
  ;  (* (matrix m) (to-matrix a)))
  ;(element-multiply [m a]
  ;  (let [[m a] (mp/broadcast-compatible m a)
  ;        a (m/coerce m a)]
  ;    (mult (matrix m) a)))

  ;mp/PMatrixDivide
  ;(element-divide
  ;  ([m] (div 1 m))
  ;  ([m a] (let [[m a] (mp/broadcast-compatible m a)
  ;               a (m/coerce m a)]
  ;           (div m a))))

  ;mp/PVectorTransform
  ;(vector-transform [m v]
  ;  (* m v))

  ;mp/PMatrixScaling
  ;(scale [m a]
  ;  (mult (matrix m) a))
  ;(pre-scale [m a]
  ;  (mult (matrix m) a))

  ;mp/PMatrixAdd
  ;(matrix-add [m a]
  ;  (let [[m a] (mp/broadcast-compatible m a)
  ;        a (m/coerce m a)
  ;        ]
  ;    (+ m a)))
  ;(matrix-sub [m a]
  ;  (let [[m a] (mp/broadcast-compatible m a)
  ;        a (m/coerce m a)]
  ;    (- m a)))

  ;mp/PMatrixAddMutable
  ;(matrix-add! [m a]
  ;  (let [a (mp/broadcast-like m a)]
  ;    (.addi (me m) (me a))))
  ;(matrix-sub! [m a]
  ;  (let [a (mp/broadcast-like m a)]
  ;    (.subi (me m) (me a))))

  ;mp/PMatrixOps
  ;(trace [m]
  ;  (trace m))
  ;(determinant [m]
  ;  (det m))
  ;(inverse [m]
  ;  (i m))
  ;(negate [m]
  ;  (* -1 m))

  ;mp/PTranspose
  ;(transpose [m] (t m))

  ;mp/PImmutableMatrixConstruction
  ;(immutable-matrix [m]
  ;  (to-vecs m))

  ;mp/PSummable
  ;  (element-sum [m]
  ;    (sum m))

  ;mp/PMatrixSlices
  ;(get-row [m i]
  ;  (slice-row m i))
  ;(get-column [m i]
  ;  (slice-column m i))
  ;(get-major-slice [m i]
  ;  (slice-row m i))
  ;(get-slice [m dimension i]
  ;  (case (long dimension)
  ;    0 (slice-row m i)
  ;    1 (slice-column m i)
  ;    (throw (UnsupportedOperationException. "Matrix only has 2 dimensions"))))

  ;mp/PSliceSeq
  ;;; API wants a seq of Vectors
  ;(get-major-slice-seq [m]
  ;  (clojure.core/map #(mp/get-major-slice-view m %) (range (nrows m))))

  ;mp/PSliceView
  ;  (get-major-slice-view [m i]
  ;    (clojure.core.matrix.impl.wrappers/wrap-slice m i))

  ;mp/PFunctionalOperations
  ;(element-seq [m]
  ;  (flatten m))
  ;(element-map
  ;  ([m f]
  ;     (map f m)) ;; note: using Clatrix map function, not clojure.core
  ;  ([m f a]
  ;     (let [rc (long (nrows m))
  ;           cc (long (ncols m))
  ;           a (mp/broadcast-coerce m a)
  ;           result (matrix m)]
  ;       (dotimes [i rc]
  ;         (dotimes [j cc]
  ;           (set result i j (f (get m i j) (get a i j)))))
  ;       result)))


  ;(element-map!
  ;  ([m f]
  ;    (map! f m))
  ;  ([m f a]
  ;    (map! f m (mp/broadcast-like m a))))

  ;(element-reduce
  ;  ([m f]
  ;    (ereduce f m))
  ;  ([m f init ]
  ;    (ereduce f init m)))
)

(imp/register-implementation :ndarray (zeros [2 2]))
